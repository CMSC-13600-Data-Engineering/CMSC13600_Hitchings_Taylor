# 1. Data Model
A relational data model is a way of structuring data in a database using tables, where each table represents a specific entity or concept. The data in a relational database is organized into tables that have rows and columns. Each row in a table represents a single record or instance of the entity being modeled, while each column represents an attribute or characteristic of that entity.

The relational data model is based on the principles of mathematical set theory and emphasizes the relationships between tables. In a relational database, these relationships are established through the use of foreign keys, which link records in one table to records in another table.

The main advantages of the relational data model are its simplicity, flexibility, and scalability. It allows for efficient storage and retrieval of large amounts of data and supports complex queries and transactions. The relational model is also widely used in industry and has become a standard for managing data in many applications, from simple spreadsheets to complex enterprise systems.

## Reading
Before you begin, you should read up on Django Models [https://docs.djangoproject.com/en/4.1/topics/db/models/], and Django Model Forms [https://docs.djangoproject.com/en/4.1/topics/forms/modelforms/].
Django models define the basic data model which is then compiled to the database. Django Model Forms allow the front end to populate such a database.

## User Experience
Next, we will describe the desired user experience. We don't particularly care how you implement this functionality, but all groups should have this functionality.

1. **User Management** There will be two classes of users: students and instructorss. Both students and instructors should be Django users and should be able to login through `/accounts/login`. Neither one should be a super-user, that should be reserved for you.
2. **Course Management** Instructor can create courses at `/app/create`, which should open a form that creates a course in the database. For simplicity, courses have only a single instructor, but instructors can teach multiple courses. After creation, the page should generate three unique URLS tied to the course:
   - `/app/join?course_id=xyz` A logged in student can join the course
   - `/app/attendance?course_id=xyz` A logged in instructor can display a QR code
   - `/app/upload?course_id=xyz` A logged in student can upload a picture of the QR code

## Data Model (TODO)
Don't worry about implementing the full functionality yet. Instead think about the data model, what data needs to be stored and how it needs to be linked. You will edit the file `models.py` to have your data model. Your data model should

1. Associate users with a category: instructors and students
2. Associate students and instructors with courses
3. Keep track of the QR codes an instructor generate (include the time!)
4. Keep track of the QR codes student in a class upload (include the time!)

Complete `models.py` with this data model. After completion run:
```
(venv) $python manage.py migrate
```
This should run with no errors if your model is consistent. Like the diagrams discussed in class. Draw out your data model and save it to the docs folder in `docss/my-data-model.png`.

## Ask Chat-GPT to generate a data model (TODO)
Chat-GPT can generate suprisingly good data models. Experiemnt with Chat-GPT to generate a data model. Use the text in this doc and the readme to generate a prompt. Ask it to do it as a django models.py file or as more abstract sql tables.
https://chat.openai.com/chat

Write your findings below. 
1. How does your data model differ from the one generated by chat-gpt? Why is your's better (on any axis: simpler, more complete, easier to implement, etc.)?

The data model proposed by ChatGPT was defined as follows:
- users: This table stores information about both instructors and students. Each user has a unique ID, a name, an email address, and a category field to indicate whether they are an instructor or a student.
- instructors: This table stores information about instructors. Each instructor has a unique ID, which is also a foreign key to the users table.
- courses: This table stores information about courses. Each course has a unique ID, a name, and a foreign key to the instructors table to indicate who teaches the course.
- students: This table stores information about students. Each student has a unique ID, which is also a foreign key to the users table.
- course_enrollment: This table associates students with courses. Each course enrollment has a foreign key to both the students and courses tables.
- attendance: This table stores attendance information for each class meeting. Each attendance record has a foreign key to the course enrollment table to indicate which student attended the class, a date, and a boolean indicating whether the student was present or absent.
- qr_codes: This table stores information about the QR codes generated by instructors for each course. Each QR code has a unique ID, a foreign key to the courses table, a timestamp indicating when the QR code was generated, and a code string that represents the QR code itself.
- qr_code_uploads: This table stores information about the QR code uploads by students for each class meeting. Each upload has a unique ID, a foreign key to the course enrollment table to indicate which student uploaded the QR code, a foreign key to the QR codes table to indicate which QR code was uploaded, and a timestamp indicating when the upload occurred.

Unlike our data model, which contains 6 tables, the model proposed by ChatGPT elaborates 8 tables and is excessively normalized. For instance, the ChatGPT data model has a users table, an instructors table, and a students table, whereas our model has one table for users which contains a column indicating a userâ€™s type (instructor or student). We think this is a better way to represent the data, as there is no need for three separate tables when that information can be encapsulated within one attribute within a table. Moreover, ChatGPT does not provide specificity about foreign key relationships when elaborating its proposed schema, and it is missing foreign key relationships that are necessary to perform the functions of the attendance app outlined in our prompt to the chatbot. In the qr_code_uploads table in the ChatGPT data model, for instance, there are no foreign key relationships with the attendance table, whereas our data model has foreign key dependencies between Attendance, Uploaded_QRCodes, and Instructor_QRCodes to account for the flow of data required to track attendance via QR code uploads and class meeting instances. Additionally, some foreign key dependencies in the ChatGPT model do not realistically account for real-life processes and data formats, where ours does. In the qr_code_uploads table in the ChatGPT model, there is supposed to be a foreign key to the qr_codes table to indicate which QR code was uploaded, but ChatGPT does not denote the datatype for this attribute (images, string of digits, etc.), nor account for the fact that there may not be a one-to-one match between instructor-generated QR codes and student uploads (students may submit other QR codes taken from web images or other files). In contrast, our model uses the ImageField datatype in Django based on the desired functions of the attendance tracking app, and allows for cross-checking between uploaded QR codes and instructor-generated ones. Our model is more complete and functional, both in terms of the specification of foreign key relationships and data types. 

2. Visualize the chat-gpt data model in `docs/gpt-model.png`.

## Deploying Your Model (Optional, but need for next week)
Now, we will go over the steps for deploying your model too the database.

1. Make the following change to your `attendancechimp/attendancechimp/settings.py` file. You need to just add one line:
https://github.com/sjyk/cmsc13600-course-project/commit/af450e997669d1b274194c3c443350c4a46afdac

2. Then create the migrations:
```
$ python manage.py makemigrations app
```

3. Deploy the migrations
```
$ python manage.py migrate
```

You can confirm the migrations worked by running sqlite. I added one table "test", and you see it show up below as `app_test`:
```
(venv) sanjays-MacBook-Air-2:attendancechimp sanjaykrishnan$ sqlite3 db.sqlite3 
SQLite version 3.39.4 2022-09-07 20:51:41
Enter ".help" for usage hints.
sqlite> .tables
app_test                    auth_user_user_permissions
auth_group                  django_admin_log          
auth_group_permissions      django_content_type       
auth_permission             django_migrations         
auth_user                   django_session            
auth_user_groups   
```

